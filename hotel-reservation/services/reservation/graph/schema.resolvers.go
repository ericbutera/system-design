package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.64

import (
	"context"
	"fmt"
	"strconv"

	"github.com/ericbutera/system-design/hotel-reservation/services/reservation/graph/auth"
	"github.com/ericbutera/system-design/hotel-reservation/services/reservation/graph/model"
	dbModel "github.com/ericbutera/system-design/hotel-reservation/services/reservation/internal/db/model"
	"github.com/ericbutera/system-design/hotel-reservation/services/reservation/internal/reservations"
	"github.com/samber/lo"
)

// CreateReservation is the resolver for the createReservation field.
func (r *mutationResolver) CreateReservation(ctx context.Context, input model.CreateReservationInput) (*model.Reservation, error) {
	// TODO: support guest checkout (guestName, guestEmail)
	user := auth.ForContext(ctx) // only logged in users can create reservations
	reservation, err := r.Reservations.Create(ctx, &dbModel.Reservation{
		CheckIn:    reservations.TimeFromString(input.CheckInDate),
		CheckOut:   reservations.TimeFromString(input.CheckOutDate),
		Status:     string(reservations.StatusPending),
		Quantity:   input.Quantity,
		RoomTypeID: input.RoomTypeID,
		HotelID:    input.HotelID,
		GuestID:    user.ID,
	})
	if err != nil {
		return nil, err
	}
	return &model.Reservation{
		ID:         strconv.Itoa(reservation.ID),
		CheckIn:    reservations.TimeToString(reservation.CheckIn),
		CheckOut:   reservations.TimeToString(reservation.CheckOut),
		Status:     reservation.Status,
		Quantity:   reservation.Quantity, // TODO: if payment fails we need to rollback the inventory
		RoomTypeID: reservation.RoomTypeID,
		HotelID:    strconv.Itoa(reservation.HotelID),
	}, nil
}

// CancelReservation is the resolver for the cancelReservation field.
func (r *mutationResolver) CancelReservation(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: CancelReservation - cancelReservation"))
}

// ViewReservation is the resolver for the viewReservation field.
func (r *queryResolver) ViewReservation(ctx context.Context, id string) (*model.Reservation, error) {
	user := auth.ForContext(ctx)
	reservation, err := r.Reservations.GetByID(ctx, id, user.ID)
	if err != nil {
		return nil, err
	}
	return &model.Reservation{
		ID:         strconv.Itoa(reservation.ID),
		CheckIn:    reservation.CheckIn.Format("2006-01-02"),
		CheckOut:   reservation.CheckOut.Format("2006-01-02"),
		Status:     reservation.Status,
		Quantity:   reservation.Quantity,
		RoomTypeID: reservation.RoomTypeID,
		HotelID:    strconv.Itoa(reservation.HotelID),
		GuestID:    reservation.GuestID,
		PaymentID:  lo.FromPtr(reservation.PaymentID),
	}, nil
}

// ViewReservations is the resolver for the viewReservations field.
func (r *queryResolver) ViewReservations(ctx context.Context) ([]*model.Reservation, error) {
	user := auth.ForContext(ctx)
	data, err := r.Reservations.GetByUser(ctx, user.ID)
	if err != nil {
		return nil, err
	}
	results := make([]*model.Reservation, len(data))
	for i, row := range data {
		results[i] = &model.Reservation{
			ID:         strconv.Itoa(row.ID),
			CheckIn:    reservations.TimeToString(row.CheckIn),
			CheckOut:   reservations.TimeToString(row.CheckOut),
			Status:     row.Status,
			Quantity:   row.Quantity,
			RoomTypeID: row.RoomTypeID,
			HotelID:    strconv.Itoa(row.HotelID),
			PaymentID:  lo.FromPtr(row.PaymentID),
			GuestID:    row.GuestID,
		}
	}

	return results, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
